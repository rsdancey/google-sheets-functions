use std::ptr;
use anyhow::{Result, anyhow};
use log::{info, error};
use windows::core::{PCWSTR, HSTRING, BSTR};
use windows::Win32::Foundation::HWND;
use windows::Win32::System::Com::{
    CoInitializeEx, CoUninitialize, COINIT_MULTITHREADED,
    CoCreateInstance, CLSCTX_LOCAL_SERVER, CLSIDFromProgID,
};
use windows::Win32::System::Ole::{IDispatch, DISPPARAMS};
use windows::Win32::UI::WindowsAndMessaging::{FindWindowW, GetWindowThreadProcessId};

use crate::config::QuickBooksConfig;

#[derive(Debug)]
pub struct QuickBooksClient {
    config: QuickBooksConfig,
    session_ticket: Option<String>,
    company_file: Option<String>,
}

impl QuickBooksClient {
    pub fn new(config: &QuickBooksConfig) -> Result<Self> {
        Ok(Self {
            config: config.clone(),
            session_ticket: None,
            company_file: None,
        })
    }

    #[cfg(windows)]
    pub fn is_quickbooks_running(&self) -> bool {
        unsafe {
            let window = FindWindowW(
                w!("QBPOS:WndClass"),
                PCWSTR::null(),
            ).unwrap_or(HWND(ptr::null_mut()));
            
            if !window.is_invalid() {
                let mut process_id = 0u32;
                GetWindowThreadProcessId(window, Some(&mut process_id));
                if process_id != 0 {
                    return true;
                }
            }
            
            // Try standard QuickBooks Desktop window class
            let window = FindWindowW(
                w!("QBPosWindow"),
                PCWSTR::null(),
            ).unwrap_or(HWND(ptr::null_mut()));
            
            if !window.is_invalid() {
                let mut process_id = 0u32;
                GetWindowThreadProcessId(window, Some(&mut process_id));
                return process_id != 0;
            }

            false
        }
    }

    #[cfg(windows)]
    pub fn connect(&mut self) -> Result<()> {
        if !self.is_quickbooks_running() {
            return Err(anyhow!("QuickBooks is not running"));
        }

        unsafe {
            // Initialize COM
            CoInitializeEx(None, COINIT_MULTITHREADED)
                .map_err(|e| anyhow!("Failed to initialize COM: {:?}", e))?;

            // Create session manager instance
            let prog_id = HSTRING::from("QBXMLRP2.RequestProcessor.1");
            let clsid = CLSIDFromProgID(&prog_id)
                .map_err(|e| anyhow!("Failed to get CLSID: {:?}", e))?;

            let session_manager: IDispatch = CoCreateInstance(
                &clsid,
                None,
                CLSCTX_LOCAL_SERVER
            ).map_err(|e| anyhow!("Failed to create session manager: {:?}", e))?;

            // Call OpenConnection2
            let mut params = DISPPARAMS::default();
            session_manager.Invoke(
                1, // DISPID for OpenConnection2
                &GUID::zeroed(),
                0,
                DISPATCH_METHOD,
                &params,
                None,
                None,
                None,
            ).map_err(|e| anyhow!("Failed to open connection: {:?}", e))?;

            Ok(())
        }
    }

    #[cfg(windows)]
    pub fn begin_session(&mut self) -> Result<()> {
        unsafe {
            let prog_id = HSTRING::from("QBXMLRP2.RequestProcessor.1");
            let clsid = CLSIDFromProgID(&prog_id)
                .map_err(|e| anyhow!("Failed to get CLSID: {:?}", e))?;

            let session_manager: IDispatch = CoCreateInstance(
                &clsid,
                None,
                CLSCTX_LOCAL_SERVER
            ).map_err(|e| anyhow!("Failed to create session manager: {:?}", e))?;

            let mut params = DISPPARAMS::default();
            let mut result = VARIANT::default();
            session_manager.Invoke(
                2, // DISPID for BeginSession
                &GUID::zeroed(),
                0,
                DISPATCH_METHOD,
                &params,
                Some(&mut result),
                None,
                None,
            ).map_err(|e| anyhow!("Failed to begin session: {:?}", e))?;

            let ticket = result.to_string();
            self.session_ticket = Some(ticket);
            Ok(())
        }
    }

    #[cfg(windows)]
    pub fn get_company_file_name(&mut self) -> Result<String> {
        unsafe {
            let prog_id = HSTRING::from("QBXMLRP2.RequestProcessor.1");
            let clsid = CLSIDFromProgID(&prog_id)
                .map_err(|e| anyhow!("Failed to get CLSID: {:?}", e))?;

            let session_manager: IDispatch = CoCreateInstance(
                &clsid,
                None,
                CLSCTX_LOCAL_SERVER
            ).map_err(|e| anyhow!("Failed to create session manager: {:?}", e))?;

            // Get Company object
            let mut params = DISPPARAMS::default();
            let mut result = VARIANT::default();
            session_manager.Invoke(
                3, // DISPID for GetCurrentCompany
                &GUID::zeroed(),
                0,
                DISPATCH_METHOD,
                &params,
                Some(&mut result),
                None,
                None,
            ).map_err(|e| anyhow!("Failed to get company: {:?}", e))?;

            let company: IDispatch = result.try_into()?;
            
            // Get FileName property
            let mut params = DISPPARAMS::default();
            let mut result = VARIANT::default();
            company.Invoke(
                4, // DISPID for FileName property
                &GUID::zeroed(),
                0,
                DISPATCH_METHOD,
                &params,
                Some(&mut result),
                None,
                None,
            ).map_err(|e| anyhow!("Failed to get file name: {:?}", e))?;

            let file_name = result.to_string();
            self.company_file = Some(file_name.clone());
            Ok(file_name)
        }
    }

    #[cfg(windows)]
    pub fn cleanup(&mut self) -> Result<()> {
        if let Some(ticket) = self.session_ticket.take() {
            unsafe {
                let prog_id = HSTRING::from("QBXMLRP2.RequestProcessor.1");
                let clsid = CLSIDFromProgID(&prog_id)
                    .map_err(|e| anyhow!("Failed to get CLSID: {:?}", e))?;

                let session_manager: IDispatch = CoCreateInstance(
                    &clsid,
                    None,
                    CLSCTX_LOCAL_SERVER
                ).map_err(|e| anyhow!("Failed to create session manager: {:?}", e))?;
                
                // End session
                let mut params = DISPPARAMS::default();
                session_manager.Invoke(
                    5, // DISPID for EndSession
                    &GUID::zeroed(),
                    0,
                    DISPATCH_METHOD,
                    &params,
                    None,
                    None,
                    None,
                ).map_err(|e| anyhow!("Failed to end session: {:?}", e))?;
                
                // Close connection
                let params = DISPPARAMS::default();
                session_manager.Invoke(
                    6, // DISPID for CloseConnection
                    &GUID::zeroed(),
                    0,
                    DISPATCH_METHOD,
                    &params,
                    None,
                    None,
                    None,
                ).map_err(|e| anyhow!("Failed to close connection: {:?}", e))?;
                
                // Uninitialize COM
                CoUninitialize();
            }
        }
        Ok(())
    }
}

impl Drop for QuickBooksClient {
    fn drop(&mut self) {
        let _ = self.cleanup();
    }
}
